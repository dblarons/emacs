;; -*- coding: utf-8-unix -*-
;; Automatically written history of nREPL session
;; Edit at your own risk

("(player \"Aaron\" false [1, 2, 3] 0)" "ISeq" "String" "(check-ns)" "(ISeq AnyInteger)" "(->> (ns-publics 'clojure.core)
     (filter (fn [[k v]]
               (not (:macro (meta v)))))
     (map first)
     (map #(clojure.lang.Symbol/create \"clojure.core\" (name %)))
     (filter #(not (@clojure.core.typed.var-env/CLJ-VAR-ANNOTATIONS %)))
     sort
     ; print 1 per line
     ((fn [a] (println (str (count a) \" vars left\\n\")) (doseq [s a] (prn s)))))" "(-main)" "(check-ns)" "clojure.core.typed" "(clojure.core.typed)" "(clojure/core.typed)" "(cf play-game)" "(clojure.core.typed/check-ns)" "clojure.core.typed/check-ns" "(-main)" "(play-game)" "(deck)" "(get deck 4)" "(nth deck 4)" "(deck 5)" "(take 53 deck)" "(take 52 deck)" "(take 5 deck)" "(deck)" "(take 52 (cycle (into (into [] (range 1 12)) (repeat 3 10))))" "(deck)" "(take 52 (deck))" "(deck)" "(take 52 (cycle (into (into [] (range 1 12)) (repeat 3 10))))" "(take 4 (map (take 12 cycle) [[5]]))" "(take 4 (map (take 12 (cycle)) [[5]]))" "(take 4 (map cycle [[5]]))" "(take 4 (map cycle [4]))" "(take 4 (cycle [3]))" "(take 4 (cycle 5))" "(take 4 (map cycle 4))" "(take 52 (map #(%1 %2) (cycle) [(range 1 12)]))" "(take 52 (map cycle [(range 1 12) (repeat 3 10)]))" "(take 52 (map cycle (range 1 12) (repeat 3 10)))" "(take 52 (cycle ((range 1 12) (repeat 10))))" "(take 4 (conj (cycle (range 1 12)) (repeat 3 10)))" "(take 4 (conj (cycle (range 1 12)) (repeat 10)))" "(take 4 (cycle (range 1 12))(repeat 10))" "(take 4 (cycle (range 1 12) (repeat 10)))" "(take 52 (cycle (into (range 1 12) (repeat 3 10))))" "(take 52 (cycle (into (repeat 3 10) (range 1 12))))" "(repeat 3 10)" "(take 52 (cycle (into (range 1 12) (repeat 3 10))))" "(take 52 (cycle (into (range 1 12) [10, 10, 10])))" "(distinct (into [1, 2, 3] [5, 6, 7]))" "(into [1, 2, 3] [5, 6, 7])" "(into [1, 2, 3] [2, 3, 4])" "(take 52 (cycle (conj (range 1 12) [10, 10, 10])))" "(take 52 (cycle (range 1 14)))" "(cycle 52 (range 1 14))" "(take 4 (range 1 12))" "(/ 52 13)" "(/ 52 12)" "(take 52 (cycle (range 1 12)))" "(take 52 (cycle (range 1 11)))" "(range 1, 52)" "(range [1, 20])" "(take 5 (cycle [1, 2, 3]))" "(take 5 (repeat \"j\"))" "(repeat \"j\" 5)" "(repeat 5)" "(-main)" "(println (read-line))" "(-main)" "(jf)" "(-main)" "(read-line)" "(println (read-line))" "(-main)" "y" "(-main)" "y" "(-main)" "n" "(-main)" "(= \"true\" true)" "(= \"\" true)" "(= \"j\" true)" "(-main)" "(client/get \"http://api.ihackernews.com/page\")" "(-main)" "(client/get \"http://google.com\")" ":require [clj-http.client :as client]" "(-main)" "(require '[clj-http.client :as client])" "(prompt-read \"foo\")" "\"\"" "(read-line)" "nrepl" "(-main)" "jthin" "(-main)" "thing" "(-main)" "(train)" "(-main)" "(-main
                       )" "ls" "-main" "main" "-main" "(-main)" "ls" "main" "(foo)" "(foo 1)" "(require '[clojure.data.json :as json])" "(require '[clojure.json :as json])" "(require '[clojurejson :as json])" "(require '[clojure/json :as json])" "(require '[org.clojure/json :as json])" "(require '[org.clojure/data.json :as json])" "(require '[org.clojure.data.json :as json])" "(require '[clojure.data.json :as json])" "(require '[org.clojure/data.json :as json])" "(require '[org.clojure.data.json :as json])" "(require '[clojure.data.json :as json])" "(foo 2)" "lein deps" "(require ['clojure.string :as 'string])" "(require '[clojure.data.json :as json])" "(foo 2)" "(foo 1)" "(foo)" "(pprint (glitter-filter 3 (mapify (parse (slurp filename)))))" "(glitter-filter 3 (mapify (parse (slurp filename))))" "(mapify (parse (slurp filename)))" "(complement true)" "(apply max [0 1 2])" "(conj {:time \"hello\"} {:another \"thing\"})" "(conj {:time \"hello\"} [:another \"thing\"])" "(conj [0] 1)" "(into #{} (map identity [:thing1 :thing2]))" "(map identity [:clove :garlic])" "(map identity (:clove :garlic))" "(into [] (map identity [:thing1 :thing2 :thing3]))" "(into {} (map identity {:sunlight-reaction \"hello\"}))" "(int {} (map identity {:sunlight-reaction \"hello\"}))" "(identity :name \"Aaron Smith\")" "(map identity {:name \"Aaron Smith\" :occupation \"Programmer\"})" "(identity {:name \"Aaron Smith\"})" "(hit asym-hobbit-body-parts)" "(hit asym-hobbit-body-parts
                     )" "(better-symmetrize-body-parts asym-hobbit-body-parts)" "(symmetrize-body-parts asym-hobbit-body-parts)" "(inc3 7)" "(#(identity %&) 1 \"blarg\" :yip)" "(#(str %1 \" and \" %2) \"corn bread\" \"Butter beans\")" "(map #(str \"Hi, \" %)[\"Darth Vader\" \"Mr. Magoo\"])" "#(* % 3)" "(my-special-multiplier 7)" "(my-special-multiplier 4)" "(map (fn [name] (str \"Hi, \" name)) [\"Darth Vader\" \"Mr. Magoo\"])" "(announce-treasure-location {:lat 22.5 :lng 50.0})" "(defn announce-treasure-location
                     )" "(chooser [\"first\"])" "(chooser [\"first\" \"second\" \"third\" \"fourth\"])" "(chooser \"first\" \"second\")" "(chooser \"first\" \"second\" \"third\" \"fourth\")" "(chooser first)" "(chooser first second third fourth fifth)" "(favority-things \"Callie\" \"you\")" "(favority-things \"aaron\" \"callie\" \"yo\")" "(x-chop \"Aaron Smith\" \"slap\")" "(x-chop \"Kanye West\")" "(multi-arity 1 2 3 4)" "(doc reduce)" "(multi-arity 1 2 3 4)" "(multi-arity 1 2)" "(multi-arity 1 2 3)" "(multi-arity 1 2 3 4)" "(multi-arity 1 2)" "(multi-arity 1 2 3)" "(+ 1 2)" "(if true 1 2)" "(get aset :c)" "(get aset :a)" "(conj aset :b)" "aset" "(def aset #{:a :b})" "(0 [1 2 3])" "(get [1 2 3] 0)" "(:a {:a 0})" "(get {:a 0} :a)" "{get {:a 0} :a}" "{A}" "{}" "{:a 1}" "(println (str \"Name - \" name))" "name" "(def name \"Aaron\")" "(println (str \"Thing - \" \"mine\"))" "(map)" "(-main
                    )" "(-main)" "(-main
                    )" "(train)" "(-train)" "(-main)" "(+ 1 2)" "(doc reduce)" "(reduce inc [5 6 100])" "(reduce + [5 6 100])" "reduce + (5 6 100)" "(map inc [1 2 3 4])" "(println \"I'm Cuckoo for Coco Puffs\")" "(+ 1 2 3 4)")